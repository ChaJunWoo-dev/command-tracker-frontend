## 📌 프로젝트 소개

커맨드 트래커는 1대1 격투 게임 '스트리트파이터6' 영상에서 플레이어의 커맨드 입력을 자막화해주는 서비스입니다.

커맨드 시스템에 익숙치 않은 초보자는 영상을 보며 일일이 입력을 추정해야 하며, 이는 높은 진입장벽이 됩니다.

이 서비스는 AI 기반 관절 추출 모델과 후처리 알고리즘을 활용하여 플레이어의 동작을 분석하고, 이를 커맨드로 변환한 뒤 영상에 표시합니다.

덕분에 초보자도 원하는 캐릭터의 커맨드를 손쉽게 확인할 수 있습니다.


## 🔗 링크  

<div align="center">
  
[시연 영상](https://drive.google.com/file/d/1bkSmT2jVh1yR19HSS-pmg3K0qPOkGw3N/view?usp=sharing) | [API 서버 레포지토리](https://github.com/ChaJunWoo-dev/command-tracker-backend) | [워커 서버 레포지토리](https://github.com/ChaJunWoo-dev/command-tracker-video-worker)

</div>


## ⚙️ 레포지토리 구성 및 역할

### 클라이언트 레포지토리
- 사용자가 분석할 영상을 업로드하고 컷 편집할 수 있는 웹 UI를 제공합니다.
- 분석할 캐릭터 위치, 캐릭터 선택, 이메일 입력 폼을 제공합니다.
- 주요 기능
  - 영상 업로드 및 편집 UI
  - 캐릭터 위치, 캐릭터 선택, 이메일 입력 폼
  - API 서버로 영상 전송

### API 서버 레포지토리
- JWT 토큰을 검증한 후 사용자의 S3 영상 업로드 요청을 처리하고, 메시지 큐를 통해 워커 서버로 작업을 전달합니다.
- 최종 결과물의 접근 URL을 발급하여 이메일로 전송합니다.
- 클라이언트와 워커 서버 간의 중계 역할을 수행하여 유지보수성과 안정성을 높입니다.
- 주요 기능
  - 사용자 입력 값 검증 및 JWT 토큰 발급
  - JWT 토큰 검증 후 S3 영상 업로드 처리
  - 메시지 큐를 통해 워커 서버에 작업 요청 발행
  - 결과물 presigned URL 발급 및 이메일 전송
 
### 워커 서버 레포지토리
- 메시지 큐로부터 수신한 작업 요청을 기반으로, 영상 컷 편집과 AI 기반 커맨드 분석을 수행하는 Python 서버입니다.
- 주요 기능
  - FFmpeg를 이용한 영상 컷 편집  
  - AI 모델을 활용한 플레이어 동작 분석 및 커맨드 추정
  - 멀티 스레딩을 통한 AI 분석 병렬 처리
  - 추정 결과를 이미지 오버레이로 영상에 삽입 후 S3업로드

## 📑 목차

- [🛠 기술 스택](#-기술-스택)  
    - [클라이언트](#클라이언트)  
    - [RabbitMQ 도입 배경](#rabbitmq-도입-배경)
    - [Express 도입 배경](#express-도입-배경)  
- [🧠 기술적 챌린지](#-기술적-챌린지)  
    - [영상 트리밍 UI의 썸네일 생성](#영상-트리밍-ui의-썸네일-생성)  
- [🔍 작업 방식](#-작업-방식)  
    - [깃 브랜치 전략](#깃-브랜치-전략)  
    - [PR 규칙](#pr-규칙)  
    - [협업 시 신경 썼던 부분](#협업-시-신경-썼던-부분)  
- [📆 일정 및 팀원](#-일정-및-팀원)  
- [💭 개인 회고](#-개인-회고)  
    - [아쉬운 점](#아쉬운-점)  
    - [향후 개선 방향](#향후-개선-방향)  


## **🛠** 기술 스택

### 클라이언트

<span>
  <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">
  <img src="https://img.shields.io/badge/react-61DAFB?style=for-the-badge&logo=react&logoColor=black">
  <img src="https://img.shields.io/badge/vite-646CFF?style=for-the-badge&logo=vite&logoColor=white">
  <img src="https://img.shields.io/badge/zustand-000000?style=for-the-badge&logo=zustand&logoColor=white">
  <img src="https://img.shields.io/badge/tailwindcss-06B6D4?style=for-the-badge&logo=tailwindcss&logoColor=white">
</span>

### API 서버

<span>
  <img src="https://img.shields.io/badge/Node.js-339933?style=for-the-badge&logo=nodedotjs&logoColor=white">
  <img src="https://img.shields.io/badge/Express-000000?style=for-the-badge&logo=express&logoColor=white">
  <img src="https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white">
</span>

### 워커 서버

<span>
  <img src="https://img.shields.io/badge/Python-3776AB?style=for-the-badge&logo=python&logoColor=white">
  <img src="https://img.shields.io/badge/PyTorch-EE4C2C?style=for-the-badge&logo=pytorch&logoColor=white">
  <img src="https://img.shields.io/badge/FFmpeg-007808?style=for-the-badge&logo=ffmpeg&logoColor=white">
  <img src="https://img.shields.io/badge/RabbitMQ-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white">
</span>

### 배포

<span>
  <img src="https://img.shields.io/badge/vercel-E34F26?style=for-the-badge&logo=vercel&logoColor=black">
  <img src="https://img.shields.io/badge/amazonaws-232F3E?style=for-the-badge&logo=amazonaws&logoColor=black">
  <img src="https://img.shields.io/badge/CloudAMQP-FF6600?style=for-the-badge&logo=rabbitmq&logoColor=white">
</span>

### RabbitMQ 도입 배경

영상 분석 및 커맨드 추정 작업은 연산 비용이 높고 처리 시간이 긴 작업입니다. 이를 HTTP 요청–응답 구조로 처리할 경우, 요청 대기 시간이 길어질 뿐만 아니라 웹 서버와 AI 서버 모두의 안정성에 부정적인 영향을 줄 수 있습니다.

이에 따라 영상 분석 작업을 메시지 큐 기반으로 분리하여 비동기 처리 구조로 전환했습니다. 웹/API 서버는 작업 요청만 큐에 발행하고 즉시 응답하며, 워커 서버는 큐를 소비하여 독립적으로 연산을 수행합니다. 이를 통해 서버 간 결합도를 낮추고 안정적인 처리가 가능합니다.

또한 AI 워커 서버는 메시지 큐 소비와 결과 처리만 담당하므로, 웹 프레임워크 없이 동작할 수 있습니다. 그 결과 HTTP 라우팅이나 요청 처리 오버헤드를 제거하고, 영상 편집이나 분석과 같은 핵심 연산 로직에만 집중할 수 있도록 구성했습니다.

### Express 도입 배경

프론트엔드가 React 기반으로 구성되어 있고, 동일한 JavaScript 생태계인 Express를 API 서버로 채택함으로써 개발 생산성을 높일 수 있었습니다.

또한 Express의 미들웨어 구조를 활용해 사용자 입력 값 검증과 JWT 토큰 검증을 요청 초기에 처리함으로써, 유효하지 않은 요청에 대한 불필요한 S3 업로드 및 후속 작업을 사전에 차단했습니다. 이를 통해 서버 부하를 줄이고 전체 응답 속도를 개선했습니다.

## 🧠 기술적 챌린지

### 요약

- 영상 트리밍 UI에서 고정 썸네일 개수로 인한 화면 크기별 깨짐 문제를, 초기 렌더링 시 컨테이너 너비를 측정하여 필요한 개수만 생성하는 방식으로 해결
- 비디오 프레임 캡처의 비동기 특성으로 인한 콜백 중첩 문제를, seeked 이벤트를 Promise로 래핑하여 async/await 기반 순차 처리로 개선
- 원본 해상도 저장 시 발생하는 메모리 부담을, Canvas API를 활용한 다운스케일(160px)과 JPEG 55% 압축으로 프레임당 용량을 약 1/340(1.5MB → 4.5KB) 수준으로 감소시켜 개선

---

### 영상 트리밍 UI의 썸네일 생성
영상 트리밍 UI에서 사용자가 원하는 구간을 시각적으로 파악할 수 있도록 타임라인 썸네일이 필요했습니다.

#### 문제 상황
1. 고정 썸네일 개수의 한계

썸네일 개수를 고정하면 화면 크기에 따라 문제가 발생합니다.

개수가 적으면 넓은 화면에서 썸네일이 늘어나 흐릿해지고,
개수가 많으면 좁은 화면에서 썸네일이 찌그러지는 문제가 발생합니다.

2. 비디오 프레임 캡처의 비동기 특성

<video> 요소에서 특정 시점의 프레임을 캡처하려면 video.currentTime을 설정해야 합니다. 하지만 이 값을 설정한다고 해서 즉시 해당 프레임이 화면에 표시되지는 않습니다. 브라우저가 해당 시점의 영상 데이터를 찾아 디코딩하는 과정이 필요하기 때문입니다.

따라서 프레임 캡처는 seeked 이벤트가 발생한 후에 수행해야 정확한 시점의 이미지를 얻을 수 있습니다. 문제는 여러 시점의 프레임을 순차적으로 캡처해야 할 때 발생합니다. 각 캡처마다 seeked 이벤트를 기다려야 하므로, 콜백 기반으로 처리하면 중첩이 깊어지고 코드 복잡도가 높아집니다.

3. 메모리 사용량 문제

1920x1080 해상도의 프레임을 원본 크기로 저장하면 메모리 사용량이 급격히 증가합니다. 

#### 해결 방법
1. 초기 렌더링 시 컨테이너 너비 기반 썸네일 개수 계산

컴포넌트가 마운트될 때 컨테이너 너비를 측정하고, 썸네일 하나의 표시 너비(60px)로 나누어 필요한 개수를 계산합니다. 
최소 8개를 보장하되, 컨테이너가 넓으면 개수를 늘려 일정한 밀도를 유지하도록 구현했습니다.

또한, 썸네일 생성은 비디오 seek 작업을 동반하므로 비용이 큽니다. 창 크기가 변할 때마다 재생성하면 UX가 오히려 저하된다고 판단하여, 초기 로드 시 한 번만 생성하고 CSS로 유연하게 표시하는 방식을 선택했습니다.

> seek란, 비디오에서 특정 시점으로 이동하는 동작입니다. video.currentTime = 30을 설정하면 브라우저가 30초 지점의 영상 데이터를 찾아 디코딩하는 과정이 발생하고, 이 과정이 완료되면 seeked 이벤트가 발생합니다.
> seek는 순차 처리로 이루어져야 합니다. video.currentTime 값은 하나만 존재하는데, 만약 Promise.all같은 병렬 처리를 시도한다면, currentTime에는 뒤섞인 프레임이 저장됩니다. 따라서 반드시 순차 처리해야 합니다.

```
<img
 ...
  style={{
    width: `${100 / thumbs.length}%`,
  }}
  className="h-full object-cover"
/>
```

2. Promise 기반 순차 프레임 캡처

 currentTime 값도 하나만 존재하므로, seek는 병렬 처리 시 프레임이 뒤섞이게 되므로 반드시 순차로 처리해야합니다. 

 이 순차 처리를 구현하려면 두 가지 방법이 있었습니다.

- 콜백 기반

    콜백은 '기다린다'는 개념이 없기 때문에, 특정 작업이 끝난 뒤 수행하도록 하려면 콜백 안에 콜백을 넣어야합니다. 이는 콜백 지옥을 만들게 됩니다.

- Promise 래핑 + async/await
  
  만약 seeked이벤트를 Promise로 래핑하면 Promise 객체를 반환하게 되고, await으로 작업 완료를 기다리게 할 수 있습니다. 덕분에 for문으로 간단하게 순차 처리 구현이 가능합니다.

3. Canvas 기반 다운스케일 및 압축

 1920x1080 크기의 고화질 영상의 원본 프레임을 그대로 썸네일로 사용하는 것은 메모리 낭비로 이어집니다. 트리머 UI용 썸네일은 일반 영상에 비해 각각의 크기가 매우 작으므로 원본 프레임 사용은 과한 메모리 사용이기 때문입니다.

따라서 다운스케일 및 압축 작업이 필요하다고 판단했습니다.

Canvas API를 사용하여 프레임을 160px 너비로 다운스케일하고, JPEG 55% 품질로 압축했습니다.

다운스케일: 1920x1080 → 160x90(비율 유지)
품질 조정: JPEG 55%

결과적으로 프레임당 용량이 약 1.5MB에서 약 4.5KB로 감소했습니다. 이는 약 99% 개선된 수치(약 1/300)입니다.

#### 개선 계획
현재 썸네일 생성이 메인 스레드에서 동기적으로 실행되어, 생성 중에는 UI가 잠시 멈추는 현상이 있습니다. 이 때 UX개선을 위해 현재는 로딩 모달을 띄우고 있습니다.
다만, 썸네일이 만들어지고 있는 과정이 실시간으로 시각화되지 않고 있어, 긴 로딩 시간이 UX를 해칠 수 있습니다. 따라서 썸네일을 생성해서 한 번에 표시하지 않고, 점진적 렌더링을 통해 생성될 때마다 화면에 추가하여 사용자가 진행 상황을 체감할 수 있도록 개선할 계획입니다.

## 🔍 **작업 방식**

### 깃 브랜치 전략
    
Github Flow 전략을 채택했습니다. Git Flow는 develop, release, hotfix 등 브랜치가 많아서 관리가 복잡하고 작은 팀에서는 오히려 비효율적이라 생각했습니다. 반면 Github Flow는 main 브랜치를 기준으로 병합하기 때문에 빠른 개발 사이클을 가져갈 수 있어 개발 기간을 확보할 수 있다고 생각하여 적합하다고 판단했습니다. 
    
### PR 규칙
    
PR 작성 시 이슈 번호를 반드시 포함하고 템플릿을 지켜 작성하였습니다. 내용에는 변경된 내용과 코드 리뷰어가 확인해야 할 부분을 간단히 명시하였습니다. 또한 팀원의 승인이 반드시 있어야 병합할 수 있도록 하여 실수로 인한 병합을 예방하였습니다.
    
### 협업 시 신경 썼던 부분
  
의견 충돌이 발생할 수 있는 상황에서도 감정적인 표현을 배제하고, 사실과 근거 중심으로 의사소통했습니다.

예를 들어 관절 좌표 데이터를 커맨드로 변환하는 방식에 대해, 좌·우 캐릭터 위치를 기준으로 규칙 기반으로 처리할지, AI 기반 트래커를 사용할지에 대해 팀 내에서 의견이 나뉜 적이 있습니다.

이 과정에서 각자가 제안한 방식을 직접 구현 및 테스트한 뒤, 결과를 비교·검증하는 방식으로 추가 논의를 진행했고, 성능과 안정성 측면에서 더 적합한 방안을 최종적으로 채택했습니다.
    

## 📆 일정 및 팀원

진행 기간 : 5주

팀원 : 차준우, 조성경 (총 2명)

- 1주차
    - 아이디어 선정
    - POC 진행 - 캐릭터의 커맨드를 추정하기 위한 관절 데이터 추출 성능 확인
- 2주차
    - POC 진행 - 캐릭터의 커맨드를 추정하기 위한 관절 데이터 추출 성능 확인
    - 칸반 작성
    - 기술 스택 조사
- 3주차
    - 프로젝트 환경 세팅
    - 공통 컴포넌트 구현
    - 영상 편집 구현
    - 영상 업로드 구현
    - 결과물 확인 링크 메일 전송 구현
- 4주차
    - 영상 분석하여 관절 데이터 추출 구현
    - Re-ID 성능 테스트
    - 동작 학습 데이터 수집 및 AI 기반 커맨드 추출 테스트
    - 관절 데이터 기반 커맨드 추출 구현
- 5주차
    - 배포


## 💭 개인 회고

이번 프로젝트를 통해 단순히 기능을 구현하는 것을 넘어, 실제 사용자가 어떤 문제를 겪고 있는지를 정의하고, 그에 맞는 해결책을 설계하는 것이 얼마나 중요한지 체감했습니다. 또한, AI 기반 관절 추정을 처음에는 캐릭터별 학습 방식으로 구현했으나, 매번 라벨링·학습을 반복해야 해 유지보수 한계가 컸습니다. 이를 좌/우 캐릭터 구분 방식으로 전환하며, 기술적 완벽함보다 현실적 확장성을 우선하는 선택이 더 효율적일 수 있음을 배웠습니다.

### 아쉬운 점

AI 기반 커맨드 추정의 정확도에 대한 확신이 부족해, 필요한 수준보다 지나치게 완벽한 결과를 목표로 POC에 과도한 시간을 투입했습니다. 이로 인해 POC 단계에서 모델 구조, 조건식, 예외 케이스 보정에 과도한 시간을 투입하게 되었고, 결과적으로 전체 시스템 설계와 개발 일정이 지연되었습니다.

사용자 경험 개선 고려나 코드 구조 정리, 인프라 단순화같은 제품 완성도를 높이는 작업에 충분한 시간을 들이지 못한 점이 아쉬움으로 남습니다. 
앞으로는 목표 수준을 현실적으로 설정하여 기술적 완성도와 개발 속도 사이의 균형을 보다 전략적으로 관리할 계획입니다.

### 향후 개선 방향

- 캐릭터별 커맨드 추가 매핑
